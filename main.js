/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AITaggerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// ai-service.ts
var AIService = class {
  constructor(settings) {
    this.settings = settings;
  }
  async generateTags(content) {
    if (this.settings.defaultProvider === "openai") {
      return this.generateTagsWithOpenAI(content);
    } else {
      return this.generateTagsWithClaude(content);
    }
  }
  async generateTagsWithOpenAI(content) {
    if (!this.settings.openaiApiKey) {
      return { tags: [], error: "OpenAI API key not configured" };
    }
    try {
      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${this.settings.openaiApiKey}`
        },
        body: JSON.stringify({
          model: "gpt-3.5-turbo",
          messages: [
            {
              role: "system",
              content: `${this.settings.customPrompt} Generate between ${this.settings.minTags} and ${this.settings.maxTags} tags. Return only the tags as a comma-separated list, no other text.`
            },
            {
              role: "user",
              content: content.substring(0, 4e3)
            }
          ],
          max_tokens: 100,
          temperature: 0.3
        })
      });
      if (!response.ok) {
        throw new Error(`OpenAI API error: ${response.status}`);
      }
      const data = await response.json();
      const tagsText = data.choices[0].message.content.trim();
      const tags = this.parseTags(tagsText);
      return { tags };
    } catch (error) {
      return { tags: [], error: `OpenAI error: ${error.message}` };
    }
  }
  async generateTagsWithClaude(content) {
    if (!this.settings.claudeApiKey) {
      return { tags: [], error: "Claude API key not configured" };
    }
    try {
      const response = await fetch("https://api.anthropic.com/v1/messages", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-api-key": this.settings.claudeApiKey,
          "anthropic-version": "2023-06-01"
        },
        body: JSON.stringify({
          model: "claude-3-haiku-20240307",
          max_tokens: 100,
          messages: [
            {
              role: "user",
              content: `${this.settings.customPrompt} Generate between ${this.settings.minTags} and ${this.settings.maxTags} tags for this content. Return only the tags as a comma-separated list, no other text.

Content: ${content.substring(0, 4e3)}`
            }
          ]
        })
      });
      if (!response.ok) {
        throw new Error(`Claude API error: ${response.status}`);
      }
      const data = await response.json();
      const tagsText = data.content[0].text.trim();
      const tags = this.parseTags(tagsText);
      return { tags };
    } catch (error) {
      return { tags: [], error: `Claude error: ${error.message}` };
    }
  }
  parseTags(tagsText) {
    return tagsText.split(",").map((tag) => tag.trim().toLowerCase()).filter((tag) => tag.length > 0 && tag.length <= 50).slice(0, this.settings.maxTags);
  }
};

// settings.ts
var DEFAULT_SETTINGS = {
  openaiApiKey: "",
  claudeApiKey: "",
  defaultProvider: "openai",
  maxTags: 5,
  minTags: 2,
  customPrompt: "Generate relevant tags for this note content. Focus on main topics, themes, and categories. Return tags as a comma-separated list. Each tag will not contain spaces, but dashes.",
  batchProcessing: false,
  autoApplyTags: false,
  excludeExistingTags: true
};

// main.ts
var AITaggerPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.aiService = new AIService(this.settings);
    this.addRibbonIcon("tag", "Generate AI Tags", () => {
      this.generateTagsForActiveFile();
    });
    this.addCommand({
      id: "generate-tags-current-note",
      name: "Generate tags for current note",
      callback: () => {
        this.generateTagsForActiveFile();
      }
    });
    this.addCommand({
      id: "generate-tags-all-notes",
      name: "Generate tags for all notes",
      callback: () => {
        this.showBatchProcessingModal();
      }
    });
    this.addSettingTab(new AITaggerSettingTab(this.app, this));
  }
  async generateTagsForActiveFile() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian.Notice("No active file");
      return;
    }
    if (activeFile.extension !== "md") {
      new import_obsidian.Notice("Active file is not a markdown file");
      return;
    }
    await this.generateTagsForFile(activeFile);
  }
  async generateTagsForFile(file) {
    const notice = new import_obsidian.Notice("Generating tags...", 0);
    try {
      const content = await this.app.vault.read(file);
      const contentWithoutFrontmatter = this.removeYamlFrontmatter(content);
      const response = await this.aiService.generateTags(contentWithoutFrontmatter);
      if (response.error) {
        notice.hide();
        new import_obsidian.Notice(`Error: ${response.error}`);
        return;
      }
      if (response.tags.length === 0) {
        notice.hide();
        new import_obsidian.Notice("No tags generated");
        return;
      }
      const existingTags = this.extractExistingTags(content);
      let newTags = response.tags;
      if (this.settings.excludeExistingTags) {
        newTags = response.tags.filter((tag) => !existingTags.includes(tag));
      }
      if (newTags.length === 0) {
        notice.hide();
        new import_obsidian.Notice("No new tags to add");
        return;
      }
      if (this.settings.autoApplyTags) {
        await this.applyTagsToFile(file, newTags);
        notice.hide();
        new import_obsidian.Notice(`Added ${newTags.length} tags: ${newTags.join(", ")}`);
      } else {
        notice.hide();
        this.showTagPreviewModal(file, newTags);
      }
    } catch (error) {
      notice.hide();
      new import_obsidian.Notice(`Error generating tags: ${error.message}`);
    }
  }
  removeYamlFrontmatter(content) {
    const frontmatterRegex = /^---\s*\n.*?\n---\s*\n/s;
    return content.replace(frontmatterRegex, "");
  }
  extractExistingTags(content) {
    const frontmatterMatch = content.match(/^---\s*\n(.*?)\n---\s*\n/s);
    if (!frontmatterMatch) return [];
    const frontmatter = frontmatterMatch[1];
    const tagsMatch = frontmatter.match(/tags:\s*\[(.*?)\]/s) || frontmatter.match(/tags:\s*\n((?:\s*-\s*.+\n?)*)/);
    if (!tagsMatch) return [];
    if (tagsMatch[1].includes("[")) {
      return tagsMatch[1].split(",").map((tag) => tag.trim().replace(/['"]/g, ""));
    } else {
      return tagsMatch[1].split("\n").map((line) => line.trim().replace(/^-\s*/, "").replace(/['"]/g, "")).filter((tag) => tag.length > 0);
    }
  }
  async applyTagsToFile(file, tags) {
    const content = await this.app.vault.read(file);
    const newContent = this.addTagsToContent(content, tags);
    await this.app.vault.modify(file, newContent);
  }
  addTagsToContent(content, tags) {
    const frontmatterMatch = content.match(/^---\s*\n(.*?)\n---\s*\n/s);
    if (frontmatterMatch) {
      const frontmatter = frontmatterMatch[1];
      const existingTags = this.extractExistingTags(content);
      const allTags = [.../* @__PURE__ */ new Set([...existingTags, ...tags])];
      const tagsYaml = `tags: [${allTags.map((tag) => `"${tag}"`).join(", ")}]`;
      let newFrontmatter = frontmatter;
      if (frontmatter.includes("tags:")) {
        newFrontmatter = frontmatter.replace(/tags:\s*\[.*?\]/s, tagsYaml);
        newFrontmatter = newFrontmatter.replace(/tags:\s*\n((?:\s*-\s*.+\n?)*)/s, tagsYaml);
      } else {
        newFrontmatter = frontmatter + "\n" + tagsYaml;
      }
      return content.replace(frontmatterMatch[0], `---
${newFrontmatter}
---
`);
    } else {
      const tagsYaml = `tags: [${tags.map((tag) => `"${tag}"`).join(", ")}]`;
      return `---
${tagsYaml}
---

${content}`;
    }
  }
  showTagPreviewModal(file, tags) {
    new TagPreviewModal(this.app, file, tags, async (selectedTags) => {
      if (selectedTags.length > 0) {
        await this.applyTagsToFile(file, selectedTags);
        new import_obsidian.Notice(`Added ${selectedTags.length} tags: ${selectedTags.join(", ")}`);
      }
    }).open();
  }
  showBatchProcessingModal() {
    new BatchProcessingModal(this.app, this).open();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.aiService = new AIService(this.settings);
  }
};
var TagPreviewModal = class extends import_obsidian.Modal {
  constructor(app, file, tags, onSubmit) {
    super(app);
    this.file = file;
    this.tags = tags;
    this.onSubmit = onSubmit;
    this.selectedTags = new Set(tags);
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Generated Tags Preview" });
    contentEl.createEl("p", { text: `File: ${this.file.name}` });
    const tagsContainer = contentEl.createDiv({ cls: "tags-container" });
    this.tags.forEach((tag) => {
      const tagEl = tagsContainer.createDiv({ cls: "tag-item" });
      const checkbox = tagEl.createEl("input", { type: "checkbox" });
      checkbox.checked = this.selectedTags.has(tag);
      checkbox.addEventListener("change", () => {
        if (checkbox.checked) {
          this.selectedTags.add(tag);
        } else {
          this.selectedTags.delete(tag);
        }
      });
      tagEl.createSpan({ text: tag, cls: "tag-text" });
    });
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const applyButton = buttonContainer.createEl("button", { text: "Apply Selected Tags" });
    applyButton.addEventListener("click", () => {
      this.onSubmit(Array.from(this.selectedTags));
      this.close();
    });
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var BatchProcessingModal = class extends import_obsidian.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "Batch Processing" });
    contentEl.createEl("p", { text: "This will generate tags for all markdown files in your vault." });
    const warningEl = contentEl.createEl("p", { cls: "warning" });
    warningEl.setText("\u26A0\uFE0F This may take a while and consume API credits. Are you sure?");
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    const proceedButton = buttonContainer.createEl("button", { text: "Proceed" });
    proceedButton.addEventListener("click", () => {
      this.processBatch();
      this.close();
    });
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
  }
  async processBatch() {
    const files = this.app.vault.getMarkdownFiles();
    const notice = new import_obsidian.Notice(`Processing ${files.length} files...`, 0);
    let processed = 0;
    let errors = 0;
    for (const file of files) {
      try {
        await this.plugin.generateTagsForFile(file);
        processed++;
      } catch (error) {
        errors++;
        console.error(`Error processing ${file.name}:`, error);
      }
      if (processed % 10 === 0) {
        notice.setMessage(`Processed ${processed}/${files.length} files...`);
      }
    }
    notice.hide();
    new import_obsidian.Notice(`Batch processing complete. Processed: ${processed}, Errors: ${errors}`);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var AITaggerSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "AI Tagger Settings" });
    new import_obsidian.Setting(containerEl).setName("Default AI Provider").setDesc("Choose between OpenAI (ChatGPT) or Claude").addDropdown((dropdown) => dropdown.addOption("openai", "OpenAI (ChatGPT)").addOption("claude", "Claude").setValue(this.plugin.settings.defaultProvider).onChange(async (value) => {
      this.plugin.settings.defaultProvider = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("OpenAI API Key").setDesc("Your OpenAI API key").addText((text) => text.setPlaceholder("sk-...").setValue(this.plugin.settings.openaiApiKey).onChange(async (value) => {
      this.plugin.settings.openaiApiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Claude API Key").setDesc("Your Anthropic Claude API key").addText((text) => text.setPlaceholder("sk-ant-...").setValue(this.plugin.settings.claudeApiKey).onChange(async (value) => {
      this.plugin.settings.claudeApiKey = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Minimum Tags").setDesc("Minimum number of tags to generate").addSlider((slider) => slider.setLimits(1, 10, 1).setValue(this.plugin.settings.minTags).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.minTags = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Maximum Tags").setDesc("Maximum number of tags to generate").addSlider((slider) => slider.setLimits(1, 10, 1).setValue(this.plugin.settings.maxTags).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.maxTags = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Custom Prompt").setDesc("Custom prompt to use for tag generation").addTextArea((text) => text.setPlaceholder("Generate relevant tags...").setValue(this.plugin.settings.customPrompt).onChange(async (value) => {
      this.plugin.settings.customPrompt = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Auto Apply Tags").setDesc("Automatically apply generated tags without preview").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoApplyTags).onChange(async (value) => {
      this.plugin.settings.autoApplyTags = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Exclude Existing Tags").setDesc("Do not generate tags that already exist in the note").addToggle((toggle) => toggle.setValue(this.plugin.settings.excludeExistingTags).onChange(async (value) => {
      this.plugin.settings.excludeExistingTags = value;
      await this.plugin.saveSettings();
    }));
  }
};
